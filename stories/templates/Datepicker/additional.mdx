## Range-Selection DatePicker

When `mode="range"`, DatePicker allows a selection of two dates, start and end.

<Canvas of={DatepickerStories.RangeSelection}>
  <Story of={DatepickerStories.RangeSelection} />
</Canvas>

## Calendar placement : `noFlip` and `drop`

By default, the Popover component of DatePicker flips top and bottom depending on the space at the current placement. Turn it off, by setting `noFlip="true"`

<Canvas of={DatepickerStories.Flip}>
  <Story of={DatepickerStories.Flip} />
</Canvas>

## Setting the initialValue on first load

### single mode

For default `mode="single"`, use the `initialValue` prop to set the initial value of in put on first load. Note that by default dateFormat prop is DD/MM/YYYY. eg. `'["23/05/2023"]'` If dateFormat is passed in, change the initialValue accordingly.

<Canvas of={DatepickerStories.SingleMode}>
  <Story of={DatepickerStories.SingleMode} />
</Canvas>

### range mode

For `mode="range"`, use the same `initialValue` prop to set the initial value of startDate and endDate. Note that by default dateFormat prop is DD/MM/YYYY. eg. `'["23/05/2023", "15/12/2023" ]'` If dateFormat is passed in, change the initialValue accordingly.

<Canvas of={DatepickerStories.RangeMode}>
  <Story of={DatepickerStories.RangeMode} />
</Canvas>

## minDate & maxDate

When `minDate` is set, users can only select the specified date and dates beyond it. When `maxDate` is set. users can only select the specified date and dates before it. To pass in as ISOString format. eg. `minDate="2023-12-10T12:00:00.000Z" maxDate="2023-12-19T12:00:00.000Z"`
It is recommended to set the calendar's display to be within the boundaries of `minDate` and `maxDate`. Use `displayDate` prop to control the calendar's display

For better accesibility, include a hint text to let your users know what is the range of dates that they can choose from

<Canvas of={DatepickerStories.MinMax}>
  <Story of={DatepickerStories.MinMax} />
</Canvas>

## Form Context

Constraint validation is implemented in datepicker as much as possible to mimick the behaviour of native HTML form component.
We use `ElementInternals` API to implement the constraint validation.

<Canvas of={DatepickerStories.FormSubmission}>
  <Story of={DatepickerStories.FormSubmission} />
</Canvas>

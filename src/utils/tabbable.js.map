{"version":3,"file":"tabbable.js","sourceRoot":"","sources":["tabbable.ts"],"names":[],"mappings":"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","sourcesContent":["/** Determines if the specified element is tabbable using heuristics inspired by https://github.com/focus-trap/tabbable */\nfunction isTabbable(el: HTMLElement) {\n  const tag = el.tagName.toLowerCase();\n\n  // Elements with a -1 tab index are not tabbable\n  if (el.getAttribute(\"tabindex\") === \"-1\") {\n    return false;\n  }\n\n  // Elements with a disabled attribute are not tabbable\n  if (el.hasAttribute(\"disabled\")) {\n    return false;\n  }\n\n  // Elements with aria-disabled are not tabbable\n  if (el.hasAttribute(\"aria-disabled\") && el.getAttribute(\"aria-disabled\") !== \"false\") {\n    return false;\n  }\n\n  // Radios without a checked attribute are not tabbable\n  if (tag === \"input\" && el.getAttribute(\"type\") === \"radio\" && !el.hasAttribute(\"checked\")) {\n    return false;\n  }\n\n  // Elements that are hidden have no offsetParent and are not tabbable\n  if (el.offsetParent === null) {\n    return false;\n  }\n\n  // Elements without visibility are not tabbable\n  if (window.getComputedStyle(el).visibility === \"hidden\") {\n    return false;\n  }\n\n  // Audio and video elements with the controls attribute are tabbable\n  if ((tag === \"audio\" || tag === \"video\") && el.hasAttribute(\"controls\")) {\n    return true;\n  }\n\n  // Elements with a tabindex other than -1 are tabbable\n  if (el.hasAttribute(\"tabindex\")) {\n    return true;\n  }\n\n  // Elements with a contenteditable attribute are tabbable\n  if (el.hasAttribute(\"contenteditable\") && el.getAttribute(\"contenteditable\") !== \"false\") {\n    return true;\n  }\n\n  // At this point, the following elements are considered tabbable\n  return [\"button\", \"input\", \"select\", \"textarea\", \"a\", \"audio\", \"video\", \"summary\"].includes(tag);\n}\n\n/**\n * Returns the first and last bounding elements that are tabbable. This is more performant than checking every single\n * element because it short-circuits after finding the first and last ones.\n */\nexport function getTabbableBoundary(root: HTMLElement | ShadowRoot) {\n  const allElements: HTMLElement[] = [];\n\n  function walk(el: HTMLElement | ShadowRoot) {\n    if (el instanceof HTMLElement) {\n      allElements.push(el);\n\n      if (el.shadowRoot !== null && el.shadowRoot.mode === \"open\") {\n        walk(el.shadowRoot);\n      }\n    }\n\n    [...el.children].forEach((e: HTMLElement) => walk(e));\n  }\n\n  // Collect all elements including the root\n  walk(root);\n\n  // Find the first and last tabbable elements\n  const start = allElements.find(el => isTabbable(el)) ?? null;\n  const end = allElements.reverse().find(el => isTabbable(el)) ?? null;\n\n  return { start, end };\n}\n"]}
{"version":3,"file":"watch.js","sourceRoot":"","sources":["watch.ts"],"names":[],"mappings":"AAAA,mBAAmB;AACnB,EAAE;AACF,sGAAsG;AACtG,EAAE;AACF,oHAAoH;AACpH,sHAAsH;AACtH,EAAE;AACF,SAAS;AACT,EAAE;AACF,sBAAsB;AACtB,0CAA0C;AAC1C,SAAS;AACT,KAAK;AAmBL,MAAM,UAAU,KAAK,CAAC,QAAgB,EAAE,OAAsB;IAC5D,MAAM,eAAe,mBACnB,oBAAoB,EAAE,KAAK,IACxB,OAAO,CACX,CAAC;IACF,OAAO,CACL,KAAgB,EAChB,eAAqD,EAC/C,EAAE;QACR,qDAAqD;QACrD,MAAM,EAAE,MAAM,EAAE,GAAG,KAAK,CAAC;QACzB,IAAI,QAAQ,IAAI,KAAK,EAAE,CAAC;YACtB,MAAM,WAAW,GAAG,QAA2B,CAAC;YAChD,qDAAqD;YACrD,KAAK,CAAC,MAAM,GAAG,UAA2B,YAA8D;gBACtG,IAAI,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC;oBAClC,MAAM,QAAQ,GAAG,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;oBAC/C,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC;oBAEnC,IAAI,QAAQ,KAAK,QAAQ,EAAE,CAAC;wBAC1B,IAAI,CAAC,eAAe,CAAC,oBAAoB,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;4BAC5D,IAAI,CAAC,eAAe,CAA8B,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;wBAC1E,CAAC;oBACH,CAAC;gBACH,CAAC;gBAED,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;YAClC,CAAC,CAAC;QACJ,CAAC;IACH,CAAC,CAAC;AACJ,CAAC","sourcesContent":["// @watch decorator\n//\n// Runs when an observed property changes, e.g. @property or @state, but before the component updates.\n//\n// To wait for an update to complete after a change occurs, use `await this.updateComplete` in the handler. To start\n// watching after the initial update/render, use `{ waitUntilFirstUpdate: true }` or `this.hasUpdated` in the handler.\n//\n// Usage:\n//\n//  @watch('propName')\n//  handlePropChange(oldValue, newValue) {\n//    ...\n//  }\n\nimport type { LitElement } from \"lit\";\n\ntype UpdateHandler = (prev?: unknown, next?: unknown) => void;\n\ntype NonUndefined<A> = A extends undefined ? never : A;\n\ntype UpdateHandlerFunctionKeys<T extends object> = {\n  [K in keyof T]-?: NonUndefined<T[K]> extends UpdateHandler ? K : never;\n}[keyof T];\n\ninterface WatchOptions {\n  /**\n   * If true, will only start watching after the initial update/render\n   */\n  waitUntilFirstUpdate?: boolean;\n}\n\nexport function watch(propName: string, options?: WatchOptions) {\n  const resolvedOptions: Required<WatchOptions> = {\n    waitUntilFirstUpdate: false,\n    ...options\n  };\n  return <ElemClass extends LitElement>(\n    proto: ElemClass,\n    decoratedFnName: UpdateHandlerFunctionKeys<ElemClass>\n  ): void => {\n    // @ts-expect-error -- update is a protected property\n    const { update } = proto;\n    if (propName in proto) {\n      const propNameKey = propName as keyof ElemClass;\n      // @ts-expect-error -- update is a protected property\n      proto.update = function (this: ElemClass, changedProps: Map<keyof ElemClass, ElemClass[keyof ElemClass]>) {\n        if (changedProps.has(propNameKey)) {\n          const oldValue = changedProps.get(propNameKey);\n          const newValue = this[propNameKey];\n\n          if (oldValue !== newValue) {\n            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {\n              (this[decoratedFnName] as unknown as UpdateHandler)(oldValue, newValue);\n            }\n          }\n        }\n\n        update.call(this, changedProps);\n      };\n    }\n  };\n}\n"]}